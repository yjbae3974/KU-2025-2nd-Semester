## 일반적인 토큰

-   키워드와 연산자
    -   `if`, `else`, `while`, `return`, `int`, `float` 등
    -   `+`, `-`, `*`, `/`, `=`, `==`, `<`, `>` 등
-   주석
    -   한 줄 주석 (예: `// 이것은 주석입니다`)
    -   여러 줄 주석 (예: `/* 이것은 여러 줄 주석입니다 */`)
-   식별자
    -   변수명 (예: `x`, `total`, `index`)
    -   함수명 (예: `main`, `calculateSum`)
    -   클래스명 (예: `MyClass`, `DataProcessor`)
-   숫자
    -   정수 (예: `42`, `-7`)
    -   부동소수점 (예: `3.14`, `-0.001`)
    -   복소수 (예: `2 + 3i`)
-   공백
    -   토큰을 구분하지만 언어 구문의 일부가 아닌 공백, 탭, 줄바꿈

## 단어 인식

-   상태 기계를 사용한다.

```
s1 -> s2 -> s3 -> accept
```

-   각 상태는 입력 문자열의 조건을 나타낸다.

### 정규 언어

-   정규 언어는 정규 표현식으로 설명되거나 유한 상태 오토마타(FSA)로 인식될 수 있는 문자열의 집합이다.
-   **정의**: 유한 상태 오토마타(FSA)로 인식할 수 있는 형식 언어
-   **특징**:
    -   메모리 제한: 유한한 상태만 기억할 수 있음
    -   단순한 패턴: 복잡한 중첩 구조를 표현할 수 없음
    -   효율적 처리: 선형 시간에 패턴 매칭 가능
-   **예시**:
    -   `a*` (a가 0개 이상)
    -   `(ab)*` ("ab"가 0번 이상 반복)
    -   `a+b+` (a가 1개 이상, 그 다음 b가 1개 이상)
-   **한계**: 균형 잡힌 괄호, 회문, 복잡한 중첩 구조를 표현할 수 없음

### 정규 표현식

-   **정의**: 정규 언어를 설명하는 수학적 표기법
-   **기본 연산**:
    1. **연결**: `ab` (a 다음에 b)
    2. **합집합**: `a|b` (a 또는 b)
    3. **클레이니 스타**: `a*` (a가 0개 이상)
-   **확장된 연산자**:
    -   `+`: 1개 이상 (`a+` = `aa*`)
    -   `?`: 0개 또는 1개 (`a?` = `a|ε`)
    -   `[abc]`: 문자 클래스 (a, b, c 중 하나)
    -   `[a-z]`: 범위 (a부터 z까지)
    -   `^`: 문자열 시작
    -   `$`: 문자열 끝
-   **예시**:
    -   이메일: `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
    -   전화번호: `^\d{3}-\d{4}-\d{4}$`
    -   숫자: `^\d+$`

### 유한 상태 오토마타 (FSA)

#### DFA (결정적 유한 오토마타)

-   **정의**: DFA = (Q, Σ, δ, q₀, F)
    -   Q: 상태들의 집합
    -   Σ: 입력 알파벳
    -   δ: 전이 함수 (Q × Σ → Q)
    -   q₀: 시작 상태
    -   F: 최종 상태들의 집합
-   **특징**:
    -   **결정적**: 각 입력 심볼에 대해 정확히 하나의 다음 상태
    -   **유일한 경로**: 입력이 유일한 실행 경로를 결정
    -   **ε-전이 없음**: 입력 없이는 전이 불가능
-   **장점**:
    -   간단한 구현 (테이블 룩업)
    -   예측 가능한 동작
    -   하드웨어 친화적

#### NFA (비결정적 유한 오토마타)

-   **정의**: NFA = (Q, Σ, δ, q₀, F)
    -   Q: 상태들의 집합
    -   Σ: 입력 알파벳 ∪ {ε}
    -   δ: 전이 함수 (Q × (Σ ∪ {ε}) → P(Q))
    -   q₀: 시작 상태
    -   F: 최종 상태들의 집합
-   **특징**:
    -   **비결정적**: 각 입력에 대해 0개 이상의 다음 상태
    -   **여러 경로**: 같은 입력이 여러 실행 경로로 이어질 수 있음
    -   **ε-전이**: 입력 없이도 전이 가능
-   **장점**:
    -   복잡한 패턴에 대한 직관적 설계
    -   간결한 표현 (동등한 DFA보다 적은 상태)
    -   정규 표현식과 직접 대응

#### DFA vs NFA 비교

| 특징       | DFA                     | NFA                  |
| ---------- | ----------------------- | -------------------- |
| **전이**   | 정확히 하나의 다음 상태 | 0개 이상의 다음 상태 |
| **ε-전이** | 불가능                  | 가능                 |
| **실행**   | 유일한 경로             | 여러 경로 가능       |
| **구현**   | 간단                    | 복잡 (백트래킹 필요) |
| **메모리** | O(1)                    | O(n) (경로 추적)     |

#### 동등성 정리

-   **중요**: DFA와 NFA는 동등한 표현력을 가짐
-   모든 NFA에 대해 동등한 DFA가 존재
-   모든 DFA는 NFA의 특수한 경우
-   **변환**: 부분집합 구성법을 사용하여 NFA → DFA 변환

### 컴파일러 응용

1. **정규 표현식** → **NFA** (톰슨 알고리즘)
2. **NFA** → **DFA** (부분집합 구성법)
3. **DFA 최소화** (상태 수 감소)
4. **코드 생성** (테이블 기반 스캐너)

이 과정을 통해 정규 표현식으로 정의된 토큰들을 효율적으로 인식할 수 있는 스캐너를 생성한다.

### Recognizer
-   입력 문자열이 특정 언어에 속하는지 결정하는 장치
-   RE를 통해 DFA 또는 NFA 생성
-   플로우:
```
RE -> NFA -> DFA -> Minimized DFA -> Recognizer
```
- NFA는 parallel하게 여러 상태를 추적할 수 있지만, DFA는 단일 상태만 추적