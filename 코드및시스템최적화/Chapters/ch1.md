### 컴파일러를 배운다는 것
- 컴파일러 과목은, 다양한 SW알고리즘을 이에 접목하고, 효율적인 알고리즘을 고민해보는 과정이다.
- `Code Tuning`을 통해, `Higher performance`를 낼 수 있다.

### Large O
- 시간복잡도, 공간복잡도를 나타내는 표기법
- `O(n³)`의 뜻은, `0< f(n) < c*n³ (n>n₀)` 인 함수 `f(n)`이 존재한다는 뜻이다. 이때 `C > 0, n₀ > 0`이며, `C`가 작을수록 하드웨어 성능이 좋다고 할 수 있다.
- 예시
  - `O(1)`: 상수시간
  - `O(log n)`: 이진탐색
  - `O(n)`: 선형탐색
  - `O(n log n)`: 병합정렬, 퀵정렬
  - `O(n²)`: 버블정렬, 삽입정렬, 선택정렬
  - `O(2^n)`: 피보나치 수열(재귀)
  - `O(n!)`: 외판원 문제(Brute-force)
  
### data, control dependency
- data dependency: 이전 연산의 결과가 이후 연산에 영향을 미치는 경우
- control dependency: 이전 연산의 결과에 따라 이후 연산이 실행될지 말지가 결정되는 경우
- 예시
  - data dependency: `a = b + c; d = a * 2;`
  - control dependency: `if (a > b) { c = a; } else { c = b; }`
- state diagram을 그릴 때, data dependency는 화살표로, control dependency는 점선으로 표현한다.
- data dependency는 컴파일러가 최적화를 할 때, 고려해야 하는 요소이다. 예를 들어, `a = b + c; d = a * 2;` 에서, a를 바로 d에 넣어버리면, 코드가 더 효율적이게 된다.
- control dependency는 컴파일러가 최적화를 할 때, 고려하지 않아도 되는 요소이다. 예를 들어, `if (a > b) { c = a; } else { c = b; }` 에서, a와 b의 값을 미리 계산해놓고, c에 넣어버리면, 코드가 더 효율적이게 된다.

### 컴파일러의 역할
- 기본적인 의미는, 한 언어를 다른 언어로 번역하는 것이다.(at compile tiem, at run time, or both)
- 그러나 통상적으로, 고수준의 언어를 저수준의 언어로 번역하는 것을 의미한다.(예: C -> Assembly)
- 또한, 대중적으로, 컴파일러는 .exe 파일을 만드는 역할을 한다고 생각한다.
  - 그러나, 그것은 compiler, assembler, linker가 함께 하는 작업이다.

### 컴파일러의 구성
- 프론트엔드<br />
    역할: 소스 코드를 언어 규칙에 맞게 해석해 `중간 표현`(IR)으로 변환<br />
    구성요소:
    - `스캐너`(어휘 분석기): 문자 → 토큰 스트림
    - `파서`(구문 분석기): 토큰 → 구문 트리(AST)
    - 의미 분석기: 타입 검사, 이름 해석, 범위/제약 확인
    - IR 생성: AST를 타깃-독립적 IR로 변환
    - 산출물: IR, 심볼 테이블, 진단(에러/경고)
- 백엔드 <br />
    역할: IR을 특정 하드웨어용 효율적인 기계어/어셈블리로 변환<br />
    구성요소:
    - 최적화: 상수 접기, 데드 코드 제거, 인라이닝, 루프 최적화 등
    - 명령 선택: IR → 타깃 ISA 명령으로 매핑
    - 레지스터 할당: 가상 레지스터 → 물리 레지스터 배치
    - 명령 스케줄링: 파이프라인/의존성 고려한 순서 조정
    - 코드 생성: 목적 코드/어셈블리 출력
    - 산출물: 목적 파일(.o/.obj) 또는 어셈블리, 메타데이터
  